// CHECK FOR FONT COMMANDS (Pre find all fonts, store message(ii), n, start, end)
    // CHECK FOR FONT COMMANDS
    // int str_local = ;
    // while(str_local) {
    // 	str_local = 
    // }



    // GET NUMBER OF LINES NEEDED TO SHOW 'fittable' CHATLOG
	int h_index = 1;
	int m_index = DATA.size()-row+2;
	if (m_index < 0) {m_index = 0;}

    int lines = 0;
    int message_len;
    string message;
	for(m_index; m_index < DATA.size(); m_index++) {
		message = DATA[m_index];
		message_len = DATA[m_index].size();
		if(message_len > col-2) {
			lines++;
			message_len -= (col-4);
			while(message_len > col-2-NEWLINE_OFFSET) {
				lines++;
				message_len -= (col-4-NEWLINE_OFFSET);
			}
			lines++;
		}
		else {
			lines++;
		}
	}

	// CALCULATE NEW LIMIT (to start screen printing at) -- DELETE
	//incriment limit by lines-row+2 (should be zero unless extra line)
	int lim = DATA.size()-row+2;	
	if (lim < 0) {lim = 0;}
	lim += lines-row+2;
	if (lim < 0) {lim = 0;}

	m_index = DATA.size()-row+2;
	if (m_index < 0) {m_index = 0;}


	// START EVALUATING FROM chatlim, ONLY PRINT IF THERES ROOM. 		(attempt = lines tried to print, h_index = lines printed, m_index = data)
	// m_index = message index, starting at n.offset.mess.fit
	// h_index = height index,	1, to whatever -- also used to show lines printed (h_index-row+2 = lines avaliable to print)
	// lim = n.offset.lines.fit
	// run through all messages that could fit
	// only print if n.of avaliable lines >= room
	// only print if n.of lines left to print <= room
	// n. of lines left to print = lines-attempt (lines -lines tried to print)
	// lines-h_index wont work because that would change height when you need to ++ regardless of if it works
	int attempt = 0;
	// int ii, font_loc;
	// vector<int> f_start;
	// vector<int> f_end;
	// vector<char> f_type;

	for(m_index; m_index < DATA.size(); m_index++) {
		message = DATA[m_index];
		message_len = DATA[m_index].size();


		// for(ii = 0; ii < NFONTCOMMANDS; ii++) {
		// 	if(message.find(fontcommands[ii]) > 0) {
		// 		while(font_loc = message.find(fontcommands[ii]))





		// 	}
		// }





		if(message_len > col-2) {
			if(lines-attempt<=row-2) {													//
				mvwprintw(chat_win,h_index,1,(message.substr(0,col-4)+"..").c_str());	//
				h_index++;																//
			}																			//		tryprint+trunkate
			message = message.substr(col-4);											//		  h_index,attempt,message, message_len
			message_len -= (col-4);														//			  must be pointers
			attempt++;																	//
			while(message_len > col-2-NEWLINE_OFFSET) {
				if(lines-attempt<=row-2) {
					mvwprintw(chat_win,h_index,NEWLINE_OFFSET+1,(message.substr(0, col-4-NEWLINE_OFFSET)+"..").c_str());
					h_index++;
				}
				message = message.substr(col-4-NEWLINE_OFFSET);
				message_len -= (col-4-NEWLINE_OFFSET);
				attempt++;
			}
			if(lines-attempt<=row-2) {
				mvwprintw(chat_win,h_index,NEWLINE_OFFSET+1,message.c_str());
				h_index++;
			}
			attempt++;
		}
		else {
			if(lines-attempt<=row-2) {
				mvwprintw(chat_win,h_index,1,message.c_str());
				h_index++;
			}
			attempt++;
		}
	}







		if(message_len>col-2) {
		message_lines++;
		message_len -= col-4;
		int temp = message_len/(col-4-NEWLINE_OFFSET);
		message_lines += temp;
		}
		else {message_lines = 1;}










    int m_index;
    vector<string> lines;
    lines.reserve(100);

	int lim = DATA.size()-row+2;
	if (lim < 0) {lim = 0;}
 	for(m_index = lim; m_index < DATA.size(); m_index++) {
    // for(m_index = DATA.size()-1; m_index > 0; m_index--) {
		message = DATA[m_index];
		message_len = DATA[m_index].size();
		// message_lines = 0;
		if(message_len>col-2) {
			// message_lines++;
			message_len -= col-2;
			message = message.substr(0,col-2);
			lines.push_back(message + "..");
			while(message_len>col-4-NEWLINE_OFFSET) {
				message_len -= col-2-NEWLINE_OFFSET;
				message = message.substr(0,col-2-NEWLINE_OFFSET);
				lines.push_back(message + "..");
			}
			lines.push_back(message);
		}
		else {
			// message_lines = 1;
			lines.push_back(message);	
		}













		for(ii = 0; ii < NFONTCOMMANDS; ii++) {
			int font_loc;
			int message_len_sofar = 0;
			int prev_len = 0;
			while(font_loc = message.find(fontcommands[ii]) != string::npos) {
				int font_size = fontcommands[ii].size();
				int font_end = message.substr(font_loc).find("}");				//check

				if(font_end == string::npos) {						//if not closed
					message = message.erase(font_loc,font_size);	//remove command
					message_len_sofar += message.size(); 			//print the rest
					printMessage(message, message_lines, &h_index, &attempt, &message_len_sofar, prev_len);
				}
				else {
					// print pre command
					string message_seg = message.substr(0,font_loc-1);
					message_len_sofar += message_seg.size(); 
					printMessage(message_seg, message_lines, &h_index, &attempt, &message_len_sofar, prev_len);
					prev_len = message_len_sofar;
					//message len = 15, so no wrap

					// print command in bold
					attron(A_BOLD);
					message_seg = message.substr(font_loc+font_size,font_end);
					message_len_sofar += message_seg.size(); 
					printMessage(message_seg, message_lines, &h_index, &attempt, &message_len_sofar, prev_len);
					prev_len = message_len_sofar;
					//message len = 15+6, so wrap
					attroff(A_BOLD);

					// truncate message now?
					//print rest? - no it prints that next loop; print the rest in
				}
				//find what font here
			}
		}











//print+fontcommands explinations


//loop through printing each line
//if line to long, print what you can
//then print the last bit on the next line
//repeat till printed
//if there is a spaced line, you need to start one line later.
//calc how much later first.































	//if no /, print
	//if /, look for command.
	//if no command, print
	//if command, print upto, print command, and trunkate
	//if no more commands, print

	//  string:    /b{say /i{hey} you}
	//	opp:      /b(say), /bi(hey), /i( you)
	//	out:         SAY *HEY* *you*

	// go until command, then go until another command.
	// call function that returns 2 vectors, 1 holding string, other holding attributes. 
	// loop through the vectors to print all. 

	// function must go to command, then go till command, then stop at bracket, then stop at bracket.
	// if command, call itself; if bracket, quit itself.


	// 	/b{lol/i{hey}you} 
	//                      <"lol", "hey", "you"> and <"b", "bi", "b">
	// goes until /b{
	// stores lol in vector as it hit /i{
	// --it would append /i{hey}you to term in vector if it couldnt find command
	// stores hey in vector as it hit }
	// stores you in vector as it hit }

	// or, goes until /b{ then pushes all before and n to vectors.
	// continues till /i{ then pushes all before and b to vectors.
	// continues until } then pushes all before and i to vectors.
	// continues until }  then pushes all before and b to vectors.
	// continues until end,  then pushes all before and n to vectors..
	// res: /b{hey /i{you} lol = HEY *YOU* LOL


	// or, goes until /b{ then prints all before, trunks message, adds bold.
	// continues till /i{ then prints all before, trunks message, adds ital.
	// continues until } then prints all before, trunks message, removes last added effect.
	// continues until } then prints all before, trunks message, removes last added effect.
	// continues until end, prints all before.
	// res: /b{hey /i{you} lol = HEY *YOU* LOL


	// OLD BUGLIST:
	// if(a=b!=c) invalud -- instead, ((a=b)!=c)
	// attron vs wattron
	// newline in function
	// if vs else if in middle
	// ^^ neither work, do the one with the smaller position

	//UPGRADES: create message_seg outside
	// BUGS: /b{/u{text}text} crashes




// FINAL PROCESS:
// calc n. of fittable lines
// calc n. offset for lines
// calc n. offset for messages
// try and print all values between n.o.messages and DATA.end()
// only print the values if (n. off lines left <= room)

//BUGS+FIXES
// Text can print below screen if wrapped (Calc n. of lines)
// Text can print below screen at start if wrapped (add lines and lim seperatly)
// Wrapped text dissapears all at once ()

